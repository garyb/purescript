{-# LANGUAGE DeriveGeneric #-}

module Language.PureScript.Kinds where

import Prelude.Compat

import GHC.Generics (Generic)
import Control.DeepSeq (NFData)
import Data.Text (Text)
import qualified Data.Text as T
import Data.Aeson.BetterErrors (Parse, key, asText, asIntegral, nth, fromAesonParser, throwCustomError)
import Data.Aeson ((.=))
import qualified Data.Aeson as A

import Language.PureScript.Names
import qualified Language.PureScript.Constants as C

-- | The data type of kinds
data Kind a
  -- | Unification variable of type Kind
  = KUnknown a Int
  -- | Kinds for labelled, unordered rows without duplicates
  | Row a (Kind a)
  -- | Function kinds
  | FunKind a (Kind a) (Kind a)
  -- | A named kind
  | NamedKind a (Qualified (ProperName 'KindName))
  deriving (Show, Eq, Ord, Generic, Functor)

instance NFData a => NFData (Kind a)

-- This is equivalent to the derived Aeson ToJSON instance, except that we
-- write it out manually so that we can define a parser which is
-- backwards-compatible.
instance A.ToJSON a => A.ToJSON (Kind a) where
  toJSON kind = case kind of
    KUnknown ann i ->
      obj ann "KUnknown" i
    Row ann k ->
      obj ann "Row" k
    FunKind ann k1 k2 ->
      obj ann "FunKind" [k1, k2]
    NamedKind ann n ->
      obj ann "NamedKind" n
    where
    obj :: (A.ToJSON a, A.ToJSON b) => a -> Text -> b -> A.Value
    obj ann tag contents =
      A.object [ "tag" .= tag, "contents" .= contents, "ann" .= ann ]

-- This is equivalent to the derived Aeson FromJSON instance, except that it
-- also handles JSON generated by compilers up to 0.10.3 and maps them to the
-- new representations (i.e. NamedKinds which are defined in the Prim module).
kindFromJSON :: forall a. a -> Parse Text a -> Parse Text (Kind a)
kindFromJSON defaultAnn annFromJSON = go where
  go = do
    t <- key "tag" asText
    ann <- key "ann" annFromJSON -- TODO-ann: make optional, can use defaultAnn if it fails
    case t of
      "KUnknown" ->
        KUnknown ann <$> key "contents" (nth 0 asIntegral)
      "Star" ->
        pure kindType
      "Row" ->
        Row ann <$> key "contents" go
      "FunKind" ->
        let
          kindAt n = key "contents" (nth n go)
        in
          FunKind ann <$> kindAt 0 <*> kindAt 1
      "Symbol" ->
        pure kindSymbol
      "NamedKind" ->
        NamedKind ann <$> key "contents" fromAesonParser
      other ->
        throwCustomError (T.append "Unrecognised tag: " other)

  -- The following are copied from Environment and reimplemented to avoid
  -- circular dependencies.
  primName :: Text -> Qualified (ProperName b)
  primName = Qualified (Just $ ModuleName [ProperName C.prim]) . ProperName

  primKind :: Text -> Kind a
  primKind = NamedKind defaultAnn . primName

  kindType = primKind "Type"
  kindSymbol = primKind "Symbol"

-- TODO-ann: can't have this instance as long as we need `kindFromJSON` to accept a default annotation for the older format(s)
-- instance A.FromJSON a => A.FromJSON (Kind a) where
--   parseJSON = toAesonParser id kindFromJSON

everywhereOnKinds :: (Kind a -> Kind a) -> Kind a -> Kind a
everywhereOnKinds f = go
  where
  go (Row ann k1) = f (Row ann (go k1))
  go (FunKind ann k1 k2) = f (FunKind ann (go k1) (go k2))
  go other = f other

everywhereOnKindsM :: Monad m => (Kind a -> m (Kind a)) -> Kind a -> m (Kind a)
everywhereOnKindsM f = go
  where
  go (Row ann k1) = (Row ann <$> go k1) >>= f
  go (FunKind ann k1 k2) = (FunKind ann <$> go k1 <*> go k2) >>= f
  go other = f other

everythingOnKinds :: (r -> r -> r) -> (Kind a -> r) -> Kind a -> r
everythingOnKinds (<>) f = go
  where
  go k@(Row _ k1) = f k <> go k1
  go k@(FunKind _ k1 k2) = f k <> go k1 <> go k2
  go other = f other
